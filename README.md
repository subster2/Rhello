# Метрические алгоритмы классификации

**Метрический классификатор (similarity-based classifier)**  - алгоритм классификации, основанный на вычислении оценок сходства между объектами.

Иными словами метрический классификатор основан на **гипотеза компактности** (Схожим объектам соответствуют схожие ответы).
Схожесть объектов мы можем определить введя в **функцию расстояния** ![](http://www.machinelearning.ru/mimetex/?\rho(x,x%27)) в пространстве объектов **Х**.

Пример сложной задачи для классификации:  
![alt text](https://github.com/subster2/Rhello/blob/master/KNN-simple/%D0%91%D0%B5%D0%B7%D1%8B%D0%BC%D1%8F%D0%BD%D0%BD%D1%8B%D0%B9.png)


## Алгоритм k ближайших соседей (kNN)

Для любого объекта **u∈Х** расположим элементы обучающей выборки **x1,x2,...,xl** по мере возрастания расстояния до **u** 
Метрический алгоритм классификации с обучающей выборкой **X** относит объект **u** к тому классу **y∈Y** , для которого суммарный вес
ближайших обучающих объектов максимален:

![](http://www.machinelearning.ru/mimetex/?a(u)%20=%20\mathrm{arg}\max_{y\in%20Y}%20\sum_{i=1}^m%20\bigl[%20x_{i;%20u}=y%20\bigr]%20w(i,u),)
где весовая функция **ω(i, u)** оценивает степень важности **i**-го соседа для классификации объекта **u**. Эта функция неотрицательна и не возрастает по **i**.

Если по-разному задавать весовую функцию, можно получать различные варианты метода ближайших соседей.

* **ω(i, u) = [i = 1]** — простейший метод ближайшего соседа;
* **ω(i, u) = [i =< k]** — метод **k** ближайших соседей;
* **ω(i, u) = [i =< k]qi** — метод **k** экспоненциально взвешенных ближайших соседей, где предполагается **q < 1**;

Рассматривать метод ближайшего соседа (1NN) смысла нет. Его недостатки и так ясны (Неустойчивость к погрешностям, зависимость от "удачности" выбора метрики, низкое качество классификации) 

Рассмотрим **KNN** для **i =< k**
```
KNN <- function(yl , point_to_classify, k , metric = euclideanDistance){
  distances <- c()
  for(i in 1:nrow(yl)){
    distances[i] <- metric(yl[i , 1:length(yl) - 1] , point_to_classify) # рассчитываем расстояние каждой точки классов до u
  }
  yl <- cbind(yl , distances)
  ordered_dist_array <- yl[order(distances),]
  k_arr <- ordered_dist_array[1:k , 3]
  class_iris <- table(k_arr) 
  return(names(which.max(class_iris))) # возвращаем название класса к которому принадлежит точка
}
```
Пример выборки IrisFishers

![alt text](https://github.com/subster2/Rhello/blob/master/KNN-simple/RKnn.png)


