1)«апишите последовательности вызовов CAR и CDR, выдел€ющие из приведен-
ных ниже списков символ цель. ”простите эти вызовы с помощью комбинации
селекторов:
Х (1 2 цель 3 4)
Х ((1) (2 цель) (3 (4)))
Х ((1 (2 (3 4 цель))))

(caddr `(1 2 цель 3 4))
(cadadr `(1 (2 цель) 3 4))
(caddar(cdadar `((1 (2 (3 4 цель))))))


12)ќпределите функцию, замен€ющую в исходном списке два подр€д идущих
одинаковых элемента одним

(defun task (lst)
 (cond ((null (cdr lst)) lst)
       ((equal (car lst) (cadr lst)) (cons (car lst) (task (cddr lst))))
       (t (cons (car lst) (task (cdr lst))))))

(print(task '(3 3 2 2 1 1 2 )))



16) ќпределите функцию, добавл€ющую элементы одного списка во второй список, начина€ с заданной позиции.

http://www.cyberforum.ru/lisp/thread1194690.html

17) —оздайте предикат, порождающий всевозможные перестановки исходного множества.
http://www.cyberforum.ru/lisp/thread1140533.html


(defun comb( ls k)
  (cond
    ((= 0 k) '(()))
    ((null ls) '())
    (t (append
            (mapcar (lambda (x) (cons (car ls) x)) (comb (cdr ls) (- k 1)))
            (comb (cdr ls) k)))))
 
(print(comb '(1 2 3) 2))
; ((1 2) (1 3) (2 3))
 
(comb '(1 2 3 4) 2)
; ((1 2) (1 3) (1 4) (2 3) (2 4) (3 4))


(defun insert (a l r)
  (cond ((null r) (list (append l (list a))))
     (t (cons (append l (list a) r) (insert a (append l (list (car r))) (cdr r))))))
 
 
(defun rotate (lst)
  (cond ((null (cdr lst)) (list lst))
     (t (apply 'append (mapcar (lambda (x) (insert (car lst) nil x)) (rotate (cdr lst)))))))


(print(rotate '(a b c )))


29)ќпределите функцию, вычисл€ющую глубину списка (самой глубокой ветви).

(   defun depth_list(list)
(cond
((atom list) 0)
((null list) 1)
 
(t 
  (max
       (+ 1 (depth_list(car list)))
        (depth_list(cdr list))
   )
)))




(print(depth_list '(1 
                        (2 3 
                           (3 4 
                              (2 3 
                                  (1)
                              )
                           )
                        )
                    
                    )))



35)ќпределите функцию ѕќƒћЌќ∆≈—“¬ќ, котора€ провер€ет, €вл€етс€ ли одно мно-
жество подмножеством другого. ќпределите также —ќЅ—“¬≈ЌЌќ≈-ѕќƒћЌќ∆≈—“¬ќ.

http://lisp.ru/page.php?id=23&pg=6

36. ќпределите предикат Ќ≈ѕ≈–≈—≈ јёў»≈—я, провер€ющий, что два множества не
пересекаютс€, т.е. у них нет общих элементов.


(defun in-predicate (a l)

    (cond

        ((null l) nil) ; элемент не может принадлежать пустому множеству

        ((eq a (car l)) t) ; элемент принадлежит множеству, если в нем содержитс€

        (t (in-predicate a (cdr l))) ; продолжаем проверку

    )

)

(defun intersection1 (a b)

    (cond

        ((null a) nil)

        ((null b) nil)

        ((in-predicate (car a) b) (print `(peresecenie)) nil ) ;(cons (car a) (intersection~ (cdr a) b)

        (t (intersection1 (cdr a) b))

    )

)

(print(intersection1 '(d l e) '(b c d) ))


38. ќпределите функцию ќЅЏ≈ƒ»Ќ≈Ќ»≈, формирующую объединение двух множеств


(defun in-predicate (a l)

    (cond

        ((null l) nil) ; элемент не может принадлежать пустому множеству

        ((eq a (car l)) t) ; элемент принадлежит множеству, если в нем содержитс€

        (t (in-predicate a (cdr l))) ; продолжаем проверку

    )

)

(defun union1 (a b)

    (cond ((null a) b)

        ((null b) a)

        ((in-predicate (car a) b) (union1 (cdr a) b) )

        (t (cons (car a) (union1 (cdr a) b)))

    )

)

 (union1 '(a b c) 'nil)


